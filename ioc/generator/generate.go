package generator

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

type Generator struct {
	components []Component
	visited    map[string]bool
}

type templateData struct {
	Imports    []string
	Components []componentInit
}

type componentInit struct {
	VarName      string
	Type         string
	Package      string
	Dependencies []componentDep
	Interfaces   []interfaceReg
}

type componentDep struct {
	FieldName string
	VarName   string
}

type interfaceReg struct {
	Interface string
	Qualifier string
	VarName   string
}

func NewGenerator(components []Component) *Generator {
	return &Generator{
		components: components,
		visited:    make(map[string]bool),
	}
}

func (g *Generator) Generate(baseDir string) error {
	if len(g.components) == 0 {
		return fmt.Errorf("no components found")
	}

	// Create wire directory if it doesn't exist
	wireDir := filepath.Join(baseDir, "wire")
	if err := os.MkdirAll(wireDir, 0755); err != nil {
		return fmt.Errorf("failed to create wire directory: %w", err)
	}

	// Generate component initializations first
	inits := g.generateComponentInits(g.components)

	// Define template functions
	funcMap := template.FuncMap{
		"base": func(pkg string) string {
			parts := strings.Split(pkg, "/")
			return parts[len(parts)-1]
		},
	}

	// Create and parse template
	tmpl := template.New("wire").Funcs(funcMap)
	tmpl, err := tmpl.Parse(`
// Code generated by go-ioc. DO NOT EDIT.
package wire

import (
    "github.com/tuhuynh27/go-ioc/ioc"{{range .Imports}}
    "{{.}}"{{end}}
)

func InitializeContainer() (*ioc.Container, error) {
    container := ioc.NewContainer()
    {{range $comp := .Components}}
    // Initialize {{$comp.Type}}
    {{$comp.VarName}} := &{{$comp.Package | base}}.{{$comp.Type}}{
        {{- range $dep := $comp.Dependencies}}
        {{$dep.FieldName}}: {{$dep.VarName}},
        {{- end}}
    }
    container.Register("{{$comp.Package}}.{{$comp.Type}}", {{$comp.VarName}})
    {{- range $comp.Interfaces}}
    container.RegisterWithInterface("{{.Interface}}", "{{.Qualifier}}", {{$comp.VarName}})
    {{- end}}
    {{end}}
    return container, nil
}
`)
	if err != nil {
		return fmt.Errorf("template parsing failed: %w", err)
	}

	// Get unique imports
	imports := make(map[string]bool)
	for _, comp := range g.components {
		if comp.Package != "" && comp.Package != "github.com/tuhuynh27/go-ioc/ioc" {
			imports[comp.Package] = true
		}
		// Add imports for interfaces
		for _, iface := range comp.Implements {
			if idx := strings.LastIndex(iface, "."); idx != -1 {
				pkgPath := iface[:idx]
				if pkgPath != "" && pkgPath != "github.com/tuhuynh27/go-ioc/ioc" {
					imports[pkgPath] = true
				}
			}
		}
	}

	// Convert imports map to sorted slice
	var importSlice []string
	for imp := range imports {
		// Skip empty or invalid imports
		if imp != "" && !strings.HasPrefix(imp, "github.com/") {
			continue
		}
		importSlice = append(importSlice, imp)
	}
	sort.Strings(importSlice)

	// Prepare template data
	data := templateData{
		Imports:    importSlice,
		Components: inits,
	}

	// Execute template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("template execution failed: %w", err)
	}

	// Write the generated code to the file
	outputPath := filepath.Join(wireDir, "wire_gen.go")
	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write generated code: %w", err)
	}

	log.Printf("Generated wire_gen.go in %s", wireDir)
	return nil
}

func (g *Generator) findPackageForType(pkgName string) string {
	for _, comp := range g.components {
		if strings.HasSuffix(comp.Package, "/"+pkgName) {
			return comp.Package
		}
	}
	return ""
}

func (g *Generator) generateComponentInits(components []Component) []componentInit {
	var inits []componentInit
	varNames := make(map[string]string)

	// First pass: create variable names for all components
	for i, comp := range components {
		varName := fmt.Sprintf("comp%d", i)
		varNames[comp.Package+"."+comp.Type] = varName
	}

	// Second pass: create component initializations
	for _, comp := range components {
		init := componentInit{
			VarName:      varNames[comp.Package+"."+comp.Type],
			Type:         comp.Type,
			Package:      comp.Package,
			Dependencies: []componentDep{},
		}

		// Add dependencies
		for _, dep := range comp.Dependencies {
			depVarName := ""
			depType := dep.Type

			if strings.Contains(depType, ".") {
				parts := strings.Split(depType, ".")
				pkgName := parts[0]
				interfaceName := parts[1]

				// Find matching component for the dependency
				for _, c := range components {
					if strings.HasSuffix(c.Package, pkgName) {
						// For MessageService interface, match by qualifier
						if interfaceName == "MessageService" {
							if dep.Qualifier == "email" && c.Type == "EmailService" {
								depVarName = varNames[c.Package+"."+c.Type]
								break
							} else if dep.Qualifier == "sms" && c.Type == "SMSService" {
								depVarName = varNames[c.Package+"."+c.Type]
								break
							}
						} else {
							// For other interfaces, check implementation
							for _, impl := range c.Implements {
								if strings.HasSuffix(impl, interfaceName) {
									depVarName = varNames[c.Package+"."+c.Type]
									break
								}
							}
						}
					}
				}
			}

			if depVarName != "" {
				init.Dependencies = append(init.Dependencies, componentDep{
					FieldName: dep.FieldName,
					VarName:   depVarName,
				})
			} else {
				log.Printf("Warning: Could not find component for dependency %s with qualifier %s", dep.Type, dep.Qualifier)
			}
		}

		inits = append(inits, init)
	}

	return inits
}

func (g *Generator) logDependencies(comp Component) {
	log.Printf("Processing dependencies for component: %s", comp.Type)
	for _, dep := range comp.Dependencies {
		log.Printf("- Dependency: %s (%s) qualifier: %s", dep.FieldName, dep.Type, dep.Qualifier)
	}
}

// Helper function to check if a slice contains a string
func contains(slice []string, str string) bool {
	for _, s := range slice {
		if strings.HasSuffix(s, str) {
			return true
		}
	}
	return false
}

func (g *Generator) orderComponentsByDependencies() []Component {
	var ordered []Component
	g.visited = make(map[string]bool)

	for _, comp := range g.components {
		if !g.visited[comp.Name] {
			g.dfsVisit(comp, &ordered)
		}
	}

	return ordered
}

func (g *Generator) dfsVisit(comp Component, ordered *[]Component) {
	g.visited[comp.Name] = true

	for _, dep := range comp.Dependencies {
		for _, other := range g.components {
			if strings.HasSuffix(other.Package, strings.Split(dep.Type, ".")[0]) &&
				strings.HasSuffix(other.Type, strings.Split(dep.Type, ".")[1]) {
				if !g.visited[other.Name] {
					g.dfsVisit(other, ordered)
				}
			}
		}
	}

	*ordered = append(*ordered, comp)
}
